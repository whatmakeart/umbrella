<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flamingo Sprite Jumper 3D</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Courier New', Courier, monospace; 
            background-color: #283b56; /* Matches the sprite sheet background color */
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        #game-container { width: 100%; height: 100vh; display: block; touch-action: none; }
        #ui-layer {
            position: absolute; top: 10px; left: 10px; color: white; 
            text-shadow: 2px 2px 0px #000; font-size: 24px; z-index: 10;
            pointer-events: none; 
            font-weight: bold;
        }
        #game-over {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); color: white;
            background: rgba(0,0,0,0.9); padding: 20px; text-align: center;
            border: 4px solid white;
            border-radius: 0px; z-index: 20;
            box-shadow: 5px 5px 0px #000;
        }
        button { 
            padding: 15px 30px; 
            font-size: 20px; 
            font-family: 'Courier New', Courier, monospace; 
            cursor: pointer; background: #ff69b4; border: 2px solid white; color: white; 
            text-transform: uppercase;
            font-weight: bold;
            touch-action: manipulation; 
        }
        button:active {
            background: #d1478e;
            transform: translateY(2px);
        }
    </style>
</head>
<body>
    <div id="ui-layer">SCORE: <span id="score">0</span></div>
    <div id="game-over">
        <h1>SPLASH!</h1>
        <p>You hit an obstacle.</p>
        <button ontouchstart="resetGame()" onclick="resetGame()">Try Again</button>
    </div>
    <div id="game-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const SPAWN_RATE_INITIAL = 1500;
        const GAME_SPEED_INITIAL = 0.12; 
        const GRAVITY = -0.015;
        const JUMP_FORCE = 0.35;
        const GROUND_LEVEL = -1;
        const LANE_WIDTH = 2;
        
        // Sprite Sheet Config
        const SPRITE_COLS = 9; // Total columns in the image
        const SPRITE_ROWS = 4; // Total rows in the image
        
        // --- Global Variables ---
        let scene, camera, renderer, flamingoGroup, flamingoSprite;
        let obstacles = [];
        let score = 0;
        let gameState = 'playing'; 
        let verticalVelocity = 0;
        let isJumping = false;
        let gameSpeed = GAME_SPEED_INITIAL;
        let lastSpawnTime = 0;
        let spawnRate = SPAWN_RATE_INITIAL;
        let clock = new THREE.Clock();

        const scoreEl = document.getElementById('score');
        const gameOverEl = document.getElementById('game-over');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            // Matching fog to the blueish background of the sprite sheet for style
            scene.fog = new THREE.FogExp2(0x283b56, 0.03);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 5); 
            camera.lookAt(0, 0.5, -5);

            renderer = new THREE.WebGLRenderer({ antialias: false }); // False for pixel art style
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(50, 100);
            // Darker ground to make the pink pop
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x1e2b40, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = GROUND_LEVEL;
            ground.receiveShadow = true;
            scene.add(ground);

            createFlamingoSprite();

            // Controls
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') attemptJump();
            });

            window.addEventListener('touchstart', (e) => {
                if(e.target.tagName === 'BUTTON') return;
                if(e.cancelable) e.preventDefault();
                attemptJump();
            }, { passive: false });

            window.addEventListener('resize', onWindowResize);
        }

        function createFlamingoSprite() {
            // Group holds the sprite and collision logic
            flamingoGroup = new THREE.Group();
            
            const loader = new THREE.TextureLoader();
            // LOAD THE UPLOADED IMAGE HERE
            loader.load('./2488.jpg', (texture) => {
                // Critical for Pixel Art look:
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                texture.colorSpace = THREE.SRGBColorSpace;

                // Setup UV Mapping for Sprite Sheet
                // repeat.x = 1 / total columns
                // repeat.y = 1 / total rows
                texture.repeat.set(1 / SPRITE_COLS, 1 / SPRITE_ROWS);
                
                // Initialize at specific frame
                // We want the "BACK" row. In UVs, (0,0) is bottom-left.
                // Row 0: Top-Down view
                // Row 1: BACK view  <-- We want this
                // Row 2: 3/4 view
                // Row 3: Side view
                texture.offset.y = 1 / 4; // 0.25 (Selects the 2nd row from bottom)

                const geometry = new THREE.PlaneGeometry(2, 2); // Size of the sprite plane
                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide,
                    alphaTest: 0.5 // Helps with cutout edges if image was PNG
                });

                flamingoSprite = new THREE.Mesh(geometry, material);
                flamingoSprite.position.y = 1; // Center the sprite relative to the group
                flamingoSprite.castShadow = true;
                
                flamingoGroup.add(flamingoSprite);
            });

            // Add a simple invisible box for collision debug if needed
            // const debugBox = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), new THREE.MeshBasicMaterial({wireframe:true, color: 'red'}));
            // flamingoGroup.add(debugBox);

            flamingoGroup.position.set(0, GROUND_LEVEL, -2);
            scene.add(flamingoGroup);
        }

        function attemptJump() {
            if (!isJumping && gameState === 'playing') {
                verticalVelocity = JUMP_FORCE;
                isJumping = true;
            }
        }

        function updateSpriteAnimation(elapsedTime) {
            if (!flamingoSprite) return;

            const texture = flamingoSprite.material.map;

            if (isJumping) {
                // JUMP FRAME: Column 5 (Index 4) looks like wings out/hover
                const jumpColumn = 4; 
                texture.offset.x = jumpColumn / SPRITE_COLS;
            } else {
                // RUN CYCLE: Columns 0, 1, 2, 3
                // Change frame every 150ms
                const frameIndex = Math.floor(elapsedTime * 8) % 4; 
                texture.offset.x = frameIndex / SPRITE_COLS;
            }
        }

        function spawnObstacle() {
            // Simplified obstacles to match pixel style
            const isWide = Math.random() > 0.5;
            let obstacleMesh;

            const boxMat = new THREE.MeshStandardMaterial({ color: 0xffea00 }); // Yellow obstacles

            if (isWide) {
                // Log/Newspaper shape
                const geo = new THREE.BoxGeometry(1.2, 0.4, 0.4);
                obstacleMesh = new THREE.Mesh(geo, boxMat);
            } else {
                // Tall block
                const geo = new THREE.BoxGeometry(0.5, 0.8, 0.5);
                obstacleMesh = new THREE.Mesh(geo, boxMat);
            }
            
            const lane = (Math.random() > 0.5 ? 1 : -1) * (LANE_WIDTH / 1.5);
            obstacleMesh.position.set(lane, GROUND_LEVEL + 0.4, -40); 
            obstacleMesh.castShadow = true;
            
            // Add a black outline to match pixel art feel
            const outlineGeo = new THREE.BoxGeometry(obstacleMesh.geometry.parameters.width + 0.05, obstacleMesh.geometry.parameters.height + 0.05, obstacleMesh.geometry.parameters.depth + 0.05);
            const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
            const outline = new THREE.Mesh(outlineGeo, outlineMat);
            obstacleMesh.add(outline);

            scene.add(obstacleMesh);
            obstacles.push(obstacleMesh);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (gameState !== 'playing') return;

            const elapsedTime = clock.getElapsedTime();
            
            // 1. Update Animation
            updateSpriteAnimation(elapsedTime);

            // 2. Physics
            score++;
            scoreEl.innerText = Math.floor(score / 10);
            gameSpeed += 0.000015; 

            verticalVelocity += GRAVITY;
            flamingoGroup.position.y += verticalVelocity;

            if (flamingoGroup.position.y <= GROUND_LEVEL) {
                flamingoGroup.position.y = GROUND_LEVEL;
                verticalVelocity = 0;
                isJumping = false;
            }

            // 3. Spawning
            const currentTime = Date.now();
            if (currentTime - lastSpawnTime > spawnRate) {
                spawnObstacle();
                lastSpawnTime = currentTime;
                spawnRate = Math.max(700, spawnRate - 15);
            }

            // 4. Collision & Movement
            // We use a smaller hitbox than the sprite because sprites have empty space
            const playerBox = new THREE.Box3();
            playerBox.setFromCenterAndSize(
                new THREE.Vector3(flamingoGroup.position.x, flamingoGroup.position.y + 0.5, flamingoGroup.position.z), 
                new THREE.Vector3(0.4, 0.8, 0.4) 
            );

            obstacles.forEach((obs, index) => {
                obs.position.z += gameSpeed;

                const obstacleBox = new THREE.Box3().setFromObject(obs);
                if (playerBox.intersectsBox(obstacleBox)) {
                    endGame();
                }

                if (obs.position.z > 6) {
                    scene.remove(obs);
                    obstacles.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        function endGame() {
            gameState = 'gameover';
            gameOverEl.style.display = 'block';
        }

        window.resetGame = function() {
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            score = 0;
            gameSpeed = GAME_SPEED_INITIAL;
            spawnRate = SPAWN_RATE_INITIAL;
            flamingoGroup.position.y = GROUND_LEVEL;
            verticalVelocity = 0;
            gameOverEl.style.display = 'none';
            gameState = 'playing';
            clock.start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        }
    </script>
</body>
</html>
