<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flamingo 3D: Forward Rush</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a0b2e; /* Deep purple night sky */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #score {
            font-size: 40px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #ff00de;
            padding: 20px;
            text-align: center;
        }
        #instructions {
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            padding-bottom: 20px;
            font-size: 16px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="loading">Loading Game Assets...</div>
    
    <div id="ui">
        <div id="score">0</div>
        <div id="instructions">
            ‚¨ÖÔ∏è LEFT | JUMP (Space) | RIGHT ‚û°Ô∏è
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>

        // --- CONFIGURATION ---
        const CONFIG = {
            spriteSrc: './1764264443243.jpg',
            cols: 11,
            rows: 4,
            rowToUse: 2, // Row 2 is the BACK view (running away)
            
            laneWidth: 120, // Distance between lanes in 3D world units
            gravity: 0.8,
            jumpForce: -16,
            baseSpeed: 15,
            
            // 3D Projection Settings
            fov: 300,
            cameraHeight: 150,
            cameraDistance: 100, // How far behind player
            horizonY: 0.4, // Screen percentage
        };

        // --- ASSETS ---
        const sprite = new Image();
        sprite.src = CONFIG.spriteSrc;
        let assetsLoaded = false;

        sprite.onload = () => {
            assetsLoaded = true;
            document.getElementById('loading').style.display = 'none';
        };
        sprite.onerror = () => {
            document.getElementById('loading').innerHTML = "Image not found.<br>Ensure '1764264443243.jpg' is in the folder.";
        };

        // --- SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            CONFIG.horizonY = height * 0.45;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- GAME STATE ---
        let frame = 0;
        let score = 0;
        let speed = CONFIG.baseSpeed;
        let gameActive = true;
        let obstacles = [];

        // --- PLAYER OBJECT ---
        const player = {
            lane: 0, // -1 (Left), 0 (Center), 1 (Right)
            x: 0,    // Interpolated X
            y: 0,    // Jump Y
            z: 0,    // Always 0 in world space
            vy: 0,
            isJumping: false,
            frameIndex: 0,
            
            update() {
                // Smooth lane switching
                const targetX = this.lane * CONFIG.laneWidth;
                this.x += (targetX - this.x) * 0.2;

                // Jump Physics
                if (this.isJumping) {
                    this.y += this.vy;
                    this.vy += CONFIG.gravity;
                    
                    if (this.y >= 0) {
                        this.y = 0;
                        this.isJumping = false;
                        this.vy = 0;
                    }
                }

                // Animation Frame
                if (frame % 4 === 0) {
                    this.frameIndex = (this.frameIndex + 1) % CONFIG.cols;
                }
            },

            draw() {
                // Project Player to Screen
                // Player is at Z=0, but we push camera back
                const scale = CONFIG.fov / (CONFIG.fov + CONFIG.cameraDistance);
                const screenX = width/2 + this.x * scale;
                const screenY = CONFIG.horizonY + (CONFIG.cameraHeight + this.y) * scale;
                
                const spriteSize = 120 * scale;

                if (assetsLoaded) {
                    const sw = sprite.width / CONFIG.cols;
                    const sh = sprite.height / CONFIG.rows;
                    
                    // Shadow
                    ctx.fillStyle = "rgba(0,0,0,0.3)";
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + spriteSize - 10*scale, spriteSize/3, spriteSize/8, 0, 0, Math.PI*2);
                    ctx.fill();

                    // Sprite
                    ctx.drawImage(
                        sprite,
                        this.frameIndex * sw, CONFIG.rowToUse * sh, sw, sh,
                        screenX - spriteSize/2, screenY - spriteSize + 10, // Anchor at feet
                        spriteSize, spriteSize
                    );
                } else {
                    // Fallback Box
                    ctx.fillStyle = 'hotpink';
                    ctx.fillRect(screenX - 25, screenY - 50, 50, 50);
                }
            }
        };

        // --- OBSTACLES ---
        const TYPES = [
            { type: 'ground', emoji: 'üöß', size: 60, yOff: 0 },
            { type: 'ground', emoji: 'ü™®', size: 50, yOff: 0 },
            { type: 'ground', emoji: 'üêä', size: 70, yOff: 0 }, // Alligator
            { type: 'air',    emoji: 'ü¶Ö', size: 60, yOff: -110 }, // Eagle (Needs jump)
            { type: 'air',    emoji: 'üõ∏', size: 70, yOff: -130 }  // UFO
        ];

        class Obstacle {
            constructor() {
                this.lane = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                this.z = 2000; // Start far away
                this.x = this.lane * CONFIG.laneWidth;
                
                const variant = TYPES[Math.floor(Math.random() * TYPES.length)];
                this.emoji = variant.emoji;
                this.sizeBase = variant.size;
                this.yOff = variant.yOff;
                this.active = true;
            }

            update() {
                this.z -= speed;
                
                // Collision Logic
                // If Z is close to player (0) and Lane matches
                if (this.active && this.z < 50 && this.z > -50) {
                    if (Math.abs(player.x - this.x) < 40) { // Approx lane check
                        // Check height for air obstacles vs jumping
                        const playerTop = player.y - 60; // Approx head
                        const playerBot = player.y;      // Feet
                        
                        const obTop = this.yOff - 30;
                        const obBot = this.yOff + 10;

                        // Simple intersection
                        if (playerBot > obTop && playerTop < obBot) {
                           gameOver();
                        }
                    }
                }
            }

            draw() {
                if (this.z < -CONFIG.cameraDistance) return;

                const scale = CONFIG.fov / (CONFIG.fov + this.z + CONFIG.cameraDistance);
                
                const screenX = width/2 + this.x * scale;
                // Calculate Y: Horizon + CameraHeight offset + Object Height Offset
                const screenY = CONFIG.horizonY + (CONFIG.cameraHeight + this.yOff) * scale;
                
                const size = this.sizeBase * scale;

                ctx.font = `${size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                
                // Opacity fade in from distance
                ctx.globalAlpha = Math.min(1, 1 - (this.z / 2000));
                ctx.fillText(this.emoji, screenX, screenY + (size/2)); // Adjust pivot
                ctx.globalAlpha = 1.0;
            }
        }

        // --- INPUT ---
        function move(dir) {
            if (!gameActive) {
                if (Date.now() - lastDeath > 500) reset();
                return;
            }
            if (dir === 'left' && player.lane > -1) player.lane--;
            if (dir === 'right' && player.lane < 1) player.lane++;
        }

        function jump() {
            if (!gameActive) {
                if (Date.now() - lastDeath > 500) reset();
                return;
            }
            if (!player.isJumping) {
                player.isJumping = true;
                player.vy = CONFIG.jumpForce;
            }
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') move('left');
            if (e.key === 'ArrowRight' || e.key === 'd') move('right');
            if (e.key === ' ' || e.key === 'ArrowUp') jump();
        });

        // Touch Input
        window.addEventListener('touchstart', e => {
            const touchX = e.touches[0].clientX;
            const w3 = width / 3;
            
            if (touchX < w3) move('left');
            else if (touchX > w3 * 2) move('right');
            else jump();
        });

        let lastDeath = 0;

        function gameOver() {
            gameActive = false;
            lastDeath = Date.now();
            
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0,0,width,height);
            ctx.fillStyle = "white";
            ctx.font = "bold 40px Arial";
            ctx.textAlign = "center";
            ctx.fillText("CRASH!", width/2, height/2);
            ctx.font = "20px Arial";
            ctx.fillText("Tap to Retry", width/2, height/2 + 50);
        }

        function reset() {
            obstacles = [];
            score = 0;
            speed = CONFIG.baseSpeed;
            player.lane = 0;
            player.x = 0;
            gameActive = true;
            scoreEl.innerText = "0";
        }

        // --- RENDER HELPERS ---
        function drawGround() {
            // Draw Sky
            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, "#0b1026");
            grad.addColorStop(0.4, "#2b1054");
            grad.addColorStop(0.4, "#ff00cc"); // Retro horizon line
            grad.addColorStop(1, "#120a2e");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // Draw Grid Floor
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, CONFIG.horizonY, width, height - CONFIG.horizonY);
            ctx.clip(); // Only draw floor below horizon

            ctx.fillStyle = "#1a0b2e";
            ctx.fill();

            // Moving Horizontal Lines (Speed effect)
            ctx.strokeStyle = "rgba(255, 0, 204, 0.3)";
            ctx.lineWidth = 2;
            
            // Logarithmic z-lines for perspective
            let offset = (frame * speed) % 100;
            for(let z=0; z<2000; z+=100) {
                let actualZ = z - offset;
                if (actualZ < 0) actualZ += 2000;
                
                const scale = CONFIG.fov / (CONFIG.fov + actualZ + CONFIG.cameraDistance);
                const screenY = CONFIG.horizonY + (CONFIG.cameraHeight + 100) * scale; // +100 to push floor down
                
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(width, screenY);
                ctx.stroke();
            }

            // Vertical Lane Lines
            ctx.strokeStyle = "rgba(0, 255, 255, 0.2)";
            const lanes = [-1.5, -0.5, 0.5, 1.5]; // Lane dividers
            lanes.forEach(laneX => {
                const worldX = laneX * CONFIG.laneWidth;
                
                // Point at horizon (vanishing point)
                const scaleFar = CONFIG.fov / (CONFIG.fov + 2000 + CONFIG.cameraDistance);
                const xFar = width/2 + worldX * scaleFar;
                const yFar = CONFIG.horizonY + (CONFIG.cameraHeight + 100) * scaleFar;

                // Point near camera
                const scaleNear = CONFIG.fov / (CONFIG.fov + 0 + CONFIG.cameraDistance);
                const xNear = width/2 + worldX * scaleNear;
                const yNear = CONFIG.horizonY + (CONFIG.cameraHeight + 100) * scaleNear;

                ctx.beginPath();
                ctx.moveTo(xFar, yFar);
                ctx.lineTo(xNear, yNear);
                ctx.stroke();
            });

            ctx.restore();
        }

        // --- MAIN LOOP ---
        function loop() {
            requestAnimationFrame(loop);
            
            ctx.clearRect(0, 0, width, height);
            drawGround();

            if (gameActive) {
                score++;
                scoreEl.innerText = Math.floor(score/10);
                speed += 0.005;

                // Spawn Obstacles
                if (frame % Math.max(20, 60 - Math.floor(score/500)) === 0) {
                    obstacles.push(new Obstacle());
                }
            }

            // Draw Objects (Sort by Z so far objects draw first)
            obstacles.sort((a,b) => b.z - a.z);
            obstacles.forEach(ob => {
                if (gameActive) ob.update();
                ob.draw();
            });
            
            // Remove passed obstacles
            obstacles = obstacles.filter(ob => ob.z > -200);

            player.update();
            player.draw();

            frame++;
        }

        loop();

    </script>
</body>
</html>

